# -*- coding: utf-8 -*-
"""Análise Estatística de Preços de Combustíveis

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1b8MkbCCS-6rPUTFb_a5UKeZVu1OqaAN5
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# --- Bloco de Funções ---

def carregar_e_limpar_dados(caminho_arquivo):
    """
    Carrega o arquivo Excel, converte a coluna de preços para numérico
    e remove dados inválidos ou nulos.
    """
    try:
        df = pd.read_excel(caminho_arquivo)
    except FileNotFoundError:
        print(f"Erro: Arquivo '{caminho_arquivo}' não encontrado.")
        return None
    except Exception as e:
        print(f"Ocorreu um erro ao ler o arquivo Excel: {e}")
        return None

    # Renomear colunas para remover espaços e caracteres especiais
    df.columns = df.columns.str.strip().str.replace(' - ', '_').str.replace(' ', '_')

    if 'Valor_de_Venda' not in df.columns:
        print("Erro: A coluna 'Valor de Venda' não foi encontrada no arquivo.")
        return None

    df['Valor_de_Venda'] = pd.to_numeric(df['Valor_de_Venda'], errors='coerce')
    df.dropna(subset=['Valor_de_Venda'], inplace=True)
    df = df[df['Valor_de_Venda'] > 0]

    return df


def calcular_estatisticas_descritivas(df, coluna_grupo, coluna_valor):
    """
    Calcula e retorna um DataFrame com as principais estatísticas descritivas
    agrupadas por uma coluna específica.
    """
    produtos_comuns = ['GASOLINA', 'ETANOL', 'DIESEL S10', 'GASOLINA ADITIVADA']
    df_filtrado = df[df[coluna_grupo].isin(produtos_comuns)]

    stats_df = pd.DataFrame()
    grouped = df_filtrado.groupby(coluna_grupo)[coluna_valor]

    stats_df['media'] = grouped.mean()
    stats_df['mediana'] = grouped.median()
    stats_df['moda'] = grouped.apply(lambda x: x.mode().iloc[0] if not x.mode().empty else None)
    stats_df['desvio_padrao'] = grouped.std()
    stats_df['variancia'] = grouped.var()
    stats_df['min'] = grouped.min()
    stats_df['25%'] = grouped.quantile(0.25)
    stats_df['75%'] = grouped.quantile(0.75)
    stats_df['max'] = grouped.quantile(1.0)
    stats_df['assimetria'] = grouped.skew()
    stats_df['curtose'] = grouped.apply(lambda x: x.kurt())  # corrigido

    return stats_df.round(4)


def calcular_matriz_covariancia(df, col_indices, col_pivot, col_valores):
    """
    Calcula e retorna a matriz de covariância para os valores de uma coluna
    pivotada.
    """
    produtos_comuns = ['GASOLINA', 'ETANOL', 'DIESEL S10', 'GASOLINA ADITIVADA']
    df_filtrado = df[df[col_pivot].isin(produtos_comuns)]

    df_pivot = df_filtrado.pivot_table(index=col_indices,
                                       columns=col_pivot,
                                       values=col_valores)
    df_pivot.dropna(inplace=True)

    if len(df_pivot) > 1:
        return df_pivot.cov().round(4)
    else:
        return "Dados insuficientes para calcular a covariância."


def gerar_graficos(df, coluna_grupo, coluna_valor):
    """
    Gera e salva os gráficos de análise (Histograma, Box Plot, Percentil, Assimetria e Curtose).
    """
    produtos_comuns = ['GASOLINA', 'ETANOL', 'DIESEL S10', 'GASOLINA ADITIVADA']
    df_filtrado = df[df[coluna_grupo].isin(produtos_comuns)]

    sns.set_theme(style="whitegrid", palette="viridis")

    # 1. Histograma e Densidade para Gasolina
    plt.figure(figsize=(10, 6))
    sns.histplot(data=df_filtrado[df_filtrado[coluna_grupo] == 'GASOLINA'],
                 x=coluna_valor, kde=True, bins=30)
    plt.title('Distribuição de Preços da Gasolina Comum', fontsize=16)
    plt.xlabel('Valor de Venda (R$ / litro)', fontsize=12)
    plt.ylabel('Frequência', fontsize=12)
    plt.savefig('histograma_gasolina.png')
    plt.show()

    # 2. Box Plot Comparativo
    plt.figure(figsize=(12, 8))
    sns.boxplot(x=coluna_grupo, y=coluna_valor, data=df_filtrado, order=produtos_comuns)
    plt.title('Dispersão dos Preços por Tipo de Combustível', fontsize=16)
    plt.xlabel('Produto', fontsize=12)
    plt.ylabel('Valor de Venda (R$ / litro)', fontsize=12)
    plt.savefig('boxplot_comparativo.png')
    plt.show()

    # 3. Gráfico de Percentil
    plt.figure(figsize=(12, 8))
    for produto in produtos_comuns:
        sns.ecdfplot(data=df_filtrado[df_filtrado[coluna_grupo] == produto],
                     x=coluna_valor, label=produto)
    plt.title('Gráfico de Percentil dos Preços por Tipo de Combustível', fontsize=16)
    plt.xlabel('Valor de Venda (R$ / litro)', fontsize=12)
    plt.ylabel('Percentil', fontsize=12)
    plt.legend()
    plt.savefig('percentil_precos.png')
    plt.show()

    # 4. Gráfico de Assimetria
    skewness_data = df_filtrado.groupby(coluna_grupo)[coluna_valor].skew().reindex(produtos_comuns)
    plt.figure(figsize=(10, 6))
    sns.barplot(x=skewness_data.index, y=skewness_data.values)
    plt.title('Assimetria dos Preços por Tipo de Combustível', fontsize=16)
    plt.xlabel('Produto', fontsize=12)
    plt.ylabel('Assimetria', fontsize=12)
    plt.savefig('assimetria_precos.png')
    plt.show()

    # 5. Gráfico de Curtose
    kurtosis_data = df_filtrado.groupby(coluna_grupo)[coluna_valor].apply(lambda x: x.kurt()).reindex(produtos_comuns)
    plt.figure(figsize=(10, 6))
    sns.barplot(x=kurtosis_data.index, y=kurtosis_data.values)
    plt.title('Curtose dos Preços por Tipo de Combustível', fontsize=16)
    plt.xlabel('Produto', fontsize=12)
    plt.ylabel('Curtose', fontsize=12)
    plt.savefig('curtose_precos.png')
    plt.show()


# --- Execução Principal ---

if __name__ == "__main__":
    arquivo_csv = "Preços_Automotivos_Parana.xlsx"

    dados = carregar_e_limpar_dados(arquivo_csv)

    if dados is not None:
        estatisticas = calcular_estatisticas_descritivas(dados, 'Produto', 'Valor_de_Venda')
        print("--- Análise Descritiva por Produto ---")
        display(estatisticas)
        print("\n" + "="*50 + "\n")

        matriz_cov = calcular_matriz_covariancia(dados,
                                                 ['CNPJ_da_Revenda', 'Data_da_Coleta'],
                                                 'Produto',
                                                 'Valor_de_Venda')
        print("--- Matriz de Covariância entre Preços ---")
        display(matriz_cov)
        print("\n" + "="*50 + "\n")

        print("Gerando gráficos de análise...")
        gerar_graficos(dados, 'Produto', 'Valor_de_Venda')
        print("Gráficos 'histograma_gasolina.png', 'boxplot_comparativo.png', "
              "'percentil_precos.png', 'assimetria_precos.png', e 'curtose_precos.png' salvos no diretório.")

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import PolynomialFeatures
from sklearn.metrics import mean_squared_error, r2_score
from scipy.optimize import curve_fit
from google.colab import files
import io

# --- Etapa 1: Carregar o Arquivo de Forma Interativa ---

print("Por favor, selecione o arquivo EXCEL (.xlsx) do seu computador.")

# Abre a janela para upload do arquivo
try:
    uploaded = files.upload()

    # Pega o nome do arquivo que você acabou de enviar
    nome_do_arquivo = next(iter(uploaded))
    print(f"\nArquivo '{nome_do_arquivo}' carregado com sucesso!")

    # Lê o arquivo EXCEL diretamente para o pandas
    # Usamos pd.read_excel() que é a função correta para arquivos .xlsx
    df = pd.read_excel(io.BytesIO(uploaded[nome_do_arquivo]))

except (StopIteration, KeyError):
    print("\nNenhum arquivo foi selecionado. Por favor, execute a célula novamente e escolha o arquivo.")
    df = None
except Exception as e:
    print(f"\nOcorreu um erro ao ler o arquivo: {e}")
    df = None


# --- O restante do código de análise (só executa se o arquivo foi carregado) ---

if df is not None:
    # Renomear colunas para remover espaços extras e garantir consistência
    df.columns = df.columns.str.strip()

    # Verifica se as colunas necessárias existem
    if 'Data da Coleta' in df.columns and 'Valor de Venda' in df.columns:
        # Converte a coluna de data para o formato datetime
        df['Data da Coleta'] = pd.to_datetime(df['Data da Coleta'])
        # Converte a coluna de valor para número, tratando erros
        df['Valor de Venda'] = pd.to_numeric(df['Valor de Venda'], errors='coerce')
        # Remove linhas que tenham valores nulos nas colunas que vamos usar
        df.dropna(subset=['Data da Coleta', 'Valor de Venda'], inplace=True)

        # Filtra para manter apenas os dados de Gasolina Comum
        if 'Produto' in df.columns:
            df_gasolina = df[df['Produto'] == 'GASOLINA'].copy()
        else:
            print("Aviso: Coluna 'Produto' não encontrada. Usando todos os dados.")
            df_gasolina = df.copy()

        if not df_gasolina.empty:
            # Agrupa os dados por dia e calcula o preço médio diário
            df_daily = df_gasolina.groupby('Data da Coleta')['Valor de Venda'].mean().reset_index()

            # Cria uma variável numérica para o tempo (número de dias desde o início)
            df_daily['Dias'] = (df_daily['Data da Coleta'] - df_daily['Data da Coleta'].min()).dt.days

            # Define as variáveis X (independente) e y (dependente)
            X = df_daily[['Dias']]
            y = df_daily['Valor de Venda']

            # --- Etapa 2: Regressão Linear Simples ---
            print("\n--- 1. Análise de Regressão Linear Simples ---")
            linear_model = LinearRegression(); linear_model.fit(X, y)
            y_pred_linear = linear_model.predict(X)
            r2_linear = r2_score(y, y_pred_linear)
            print(f"Coeficiente de Determinação (R²): {r2_linear:.4f}")
            print(f"Equação da Reta: y = {linear_model.coef_[0]:.4f}x + {linear_model.intercept_:.4f}")
            plt.figure(figsize=(12, 6)); plt.scatter(X, y, color='blue', label='Preços Médios Diários'); plt.plot(X, y_pred_linear, color='red', linewidth=2, label='Linha de Regressão Linear'); plt.title('Regressão Linear: Preço da Gasolina vs. Tempo'); plt.xlabel('Dias desde a Primeira Coleta'); plt.ylabel('Preço Médio de Venda (R$)'); plt.legend(); plt.grid(True); plt.show()

            # --- Etapa 3: Regressão Não Linear (Polinomial - Parábola) ---
            print("\n--- 2. Análise de Regressão Polinomial (Parábola) ---")
            poly_features = PolynomialFeatures(degree=2); X_poly = poly_features.fit_transform(X)
            poly_model = LinearRegression(); poly_model.fit(X_poly, y)
            y_pred_poly = poly_model.predict(X_poly)
            r2_poly = r2_score(y, y_pred_poly)
            print(f"Coeficiente de Determinação (R²): {r2_poly:.4f}")
            print(f"Equação da Parábola: y = {poly_model.coef_[2]:.6f}x² + {poly_model.coef_[1]:.4f}x + {poly_model.intercept_:.4f}")
            plt.figure(figsize=(12, 6)); plt.scatter(X, y, color='blue', label='Preços Médios Diários'); sort_axis = np.argsort(X['Dias']); plt.plot(X['Dias'].iloc[sort_axis], y_pred_poly[sort_axis], color='green', linewidth=2, label='Curva de Regressão Polinomial (Grau 2)'); plt.title('Regressão Polinomial: Preço da Gasolina vs. Tempo'); plt.xlabel('Dias desde a Primeira Coleta'); plt.ylabel('Preço Médio de Venda (R$)'); plt.legend(); plt.grid(True); plt.show()

            # --- Etapa 4: Outros Modelos de Regressão Não Linear ---
            print("\n--- Outros modelos não lineares ---")
            if len(X) > 3:
                def func_exp(x, a, b): return a * np.exp(b * x)
                print("\n--- 3. Análise de Regressão Exponencial ---")
                try:
                    popt_exp, _ = curve_fit(func_exp, X['Dias'], y, p0=(5, 0.001), maxfev=5000)
                    y_pred_exp = func_exp(X['Dias'], *popt_exp); r2_exp = r2_score(y, y_pred_exp)
                    print(f"Coeficiente de Determinação (R²): {r2_exp:.4f}"); print(f"Equação Exponencial: y = {popt_exp[0]:.4f} * e^({popt_exp[1]:.6f} * x)")
                    plt.figure(figsize=(12, 6)); plt.scatter(X, y, color='blue', label='Dados Reais'); plt.plot(X, y_pred_exp, color='purple', linewidth=2, label='Regressão Exponencial'); plt.title('Regressão Exponencial: Preço da Gasolina'); plt.xlabel('Dias'); plt.ylabel('Preço de Venda'); plt.legend(); plt.grid(True); plt.show()
                except RuntimeError: print("Não foi possível otimizar os parâmetros para o modelo exponencial.")

                def func_pot(x, a, b): return a * np.power(x + 1e-9, b)
                print("\n--- 4. Análise de Regressão de Potência ---")
                try:
                    popt_pot, _ = curve_fit(func_pot, X['Dias'], y, p0=(5, 0.1), maxfev=5000)
                    y_pred_pot = func_pot(X['Dias'], *popt_pot); r2_pot = r2_score(y, y_pred_pot)
                    print(f"Coeficiente de Determinação (R²): {r2_pot:.4f}"); print(f"Equação de Potência: y = {popt_pot[0]:.4f} * x^({popt_pot[1]:.4f})")
                    plt.figure(figsize=(12, 6)); plt.scatter(X, y, color='blue', label='Dados Reais'); plt.plot(X, y_pred_pot, color='orange', linewidth=2, label='Regressão de Potência'); plt.title('Regressão de Potência: Preço da Gasolina'); plt.xlabel('Dias'); plt.ylabel('Preço de Venda'); plt.legend(); plt.grid(True); plt.show()
                except RuntimeError: print("Não foi possível otimizar os parâmetros para o modelo de potência.")

                def func_logistica(x, L, k, x0): return L / (1 + np.exp(-k * (x - x0)))
                print("\n--- 5. Análise de Regressão Logística ---")
                try:
                    popt_log, _ = curve_fit(func_logistica, X['Dias'], y, p0=(y.max()+0.1, 0.1, X['Dias'].median()), maxfev=8000)
                    y_pred_log = func_logistica(X['Dias'], *popt_log); r2_log = r2_score(y, y_pred_log)
                    print(f"Coeficiente de Determinação (R²): {r2_log:.4f}"); print(f"Parâmetros (L, k, x0): {popt_log[0]:.4f}, {popt_log[1]:.4f}, {popt_log[2]:.4f}")
                    plt.figure(figsize=(12, 6)); plt.scatter(X, y, color='blue', label='Dados Reais'); plt.plot(X, y_pred_log, color='brown', linewidth=2, label='Regressão Logística'); plt.title('Regressão Logística: Preço da Gasolina'); plt.xlabel('Dias'); plt.ylabel('Preço de Venda'); plt.legend(); plt.grid(True); plt.show()
                except RuntimeError: print("Não foi possível otimizar os parâmetros para o modelo logístico.")
            else: print("\nNão há dados suficientes para os modelos de regressão não-linear.")

            # --- Etapa 5: Comparação dos Modelos ---
            print("\n" + "="*50); print("--- Resumo e Comparação dos Modelos ---"); print("O Coeficiente de Determinação (R²) indica o quão bem o modelo se ajusta aos dados."); print("Valores mais próximos de 1 são melhores."); print("="*50)
            print(f"R² da Regressão Linear:         {r2_linear:.4f}"); print(f"R² da Regressão Polinomial (2º):  {r2_poly:.4f}")
            if 'r2_exp' in locals(): print(f"R² da Regressão Exponencial:      {r2_exp:.4f}")
            if 'r2_pot' in locals(): print(f"R² da Regressão de Potência:         {r2_pot:.4f}")
            if 'r2_log' in locals(): print(f"R² da Regressão Logística:        {r2_log:.4f}")
            print("="*50)
        else:
            print("\nNão foram encontrados dados para 'GASOLINA' no arquivo. A análise não pode continuar.")
    else:
        print("\nErro: As colunas 'Data da Coleta' ou 'Valor de Venda' não foram encontradas no arquivo.")

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import PolynomialFeatures
from sklearn.metrics import r2_score
from scipy.optimize import curve_fit
from google.colab import files
import io
import ipywidgets as widgets
from ipywidgets import interact, Layout

# --- Etapa 1: Carregar o Arquivo de Forma Interativa ---

print("Por favor, selecione o arquivo EXCEL (.xlsx) do seu computador para iniciar o dashboard.")
try:
    uploaded = files.upload()
    nome_do_arquivo = next(iter(uploaded))
    print(f"\nArquivo '{nome_do_arquivo}' carregado com sucesso!")
    df = pd.read_excel(io.BytesIO(uploaded[nome_do_arquivo]))
except (StopIteration, KeyError):
    print("\nNenhum arquivo foi selecionado. A execução foi interrompida.")
    df = None
except Exception as e:
    print(f"\nOcorreu um erro ao ler o arquivo: {e}")
    df = None

# --- Etapa 2: Processar os Dados e Treinar TODOS os Modelos ---

if df is not None:
    # Prepara o DataFrame
    df.columns = df.columns.str.strip()
    df['Data da Coleta'] = pd.to_datetime(df['Data da Coleta'])
    df['Valor de Venda'] = pd.to_numeric(df['Valor de Venda'], errors='coerce')
    df.dropna(subset=['Data da Coleta', 'Valor de Venda'], inplace=True)
    df_gasolina = df[df['Produto'] == 'GASOLINA'].copy()

    if not df_gasolina.empty:
        df_daily = df_gasolina.groupby('Data da Coleta')['Valor de Venda'].mean().reset_index()
        df_daily['Dias'] = (df_daily['Data da Coleta'] - df_daily['Data da Coleta'].min()).dt.days
        X = df_daily[['Dias']]
        y = df_daily['Valor de Venda']
        X_flat = df_daily['Dias'] # Versão 1D para o curve_fit

        # Dicionários para armazenar os resultados
        predictions = {}
        metrics = {}
        models = {}

        # 1. Modelo Linear
        linear_model = LinearRegression()
        linear_model.fit(X, y)
        predictions['Linear'] = linear_model.predict(X)
        metrics['Linear'] = {
            'r2': r2_score(y, predictions['Linear']),
            'eq': f"y = {linear_model.coef_[0]:.4f}x + {linear_model.intercept_:.4f}"
        }

        # 2. Modelo Polinomial (Parábola)
        poly_features = PolynomialFeatures(degree=2)
        X_poly = poly_features.fit_transform(X)
        poly_model = LinearRegression()
        poly_model.fit(X_poly, y)
        predictions['Polinomial'] = poly_model.predict(X_poly)
        metrics['Polinomial'] = {
            'r2': r2_score(y, predictions['Polinomial']),
            'eq': f"y = {poly_model.coef_[2]:.6f}x² + {poly_model.coef_[1]:.4f}x + {poly_model.intercept_:.4f}"
        }

        # 3. Modelo Exponencial
        def func_exp(x, a, b): return a * np.exp(b * x)
        try:
            popt_exp, _ = curve_fit(func_exp, X_flat, y, p0=(5, 0.001), maxfev=5000)
            predictions['Exponencial'] = func_exp(X_flat, *popt_exp)
            metrics['Exponencial'] = {
                'r2': r2_score(y, predictions['Exponencial']),
                'eq': f"y = {popt_exp[0]:.4f} * e^({popt_exp[1]:.6f} * x)"
            }
        except RuntimeError:
            print("Aviso: Não foi possível calcular o modelo Exponencial.")

        # 4. Modelo de Potência
        def func_pot(x, a, b): return a * np.power(x + 1e-9, b)
        try:
            popt_pot, _ = curve_fit(func_pot, X_flat, y, p0=(5, 0.1), maxfev=5000)
            predictions['Potência'] = func_pot(X_flat, *popt_pot)
            metrics['Potência'] = {
                'r2': r2_score(y, predictions['Potência']),
                'eq': f"y = {popt_pot[0]:.4f} * x^({popt_pot[1]:.4f})"
            }
        except RuntimeError:
            print("Aviso: Não foi possível calcular o modelo de Potência.")

        # Lista de modelos que foram calculados com sucesso
        model_options = list(predictions.keys())

        # --- Etapa 3: Função para Desenhar o Dashboard ---

        def update_dashboard(modelo_selecionado):
            plt.figure(figsize=(12, 7))

            # Gráfico dos dados reais
            plt.scatter(X, y, color='skyblue', label='Preços Médios Diários')

            # Gráfico da predição do modelo selecionado
            y_pred = predictions[modelo_selecionado]
            # Ordenar para plotar a linha corretamente
            sort_axis = np.argsort(X_flat)
            plt.plot(X.iloc[sort_axis], y_pred[sort_axis], color='red', linewidth=3, label=f'Regressão {modelo_selecionado}')

            # Informações do modelo
            r2 = metrics[modelo_selecionado]['r2']
            equacao = metrics[modelo_selecionado]['eq']

            plt.title(f'Análise de Regressão: Modelo {modelo_selecionado}', fontsize=16)
            plt.xlabel('Dias desde a Primeira Coleta', fontsize=12)
            plt.ylabel('Preço Médio de Venda (R$)', fontsize=12)
            plt.legend(fontsize=12)
            plt.grid(True, linestyle='--', alpha=0.6)

            # Adiciona o texto com as métricas no gráfico
            plt.text(0.05, 0.95, f'R² = {r2:.4f}\nEquação: {equacao}',
                     transform=plt.gca().transAxes, fontsize=12, verticalalignment='top',
                     bbox=dict(boxstyle='round,pad=0.5', fc='wheat', alpha=0.5))

            plt.show()

        # --- Etapa 4: Criar o Widget Interativo ---

        print("\n" + "="*50)
        print("DASHBOARD INTERATIVO DE REGRESSÃO")
        print("Selecione um modelo no menu abaixo para visualizar o gráfico e os resultados.")
        print("="*50)

        # Cria o menu dropdown e o conecta à função do dashboard
        interact(update_dashboard, modelo_selecionado=widgets.Dropdown(options=model_options, description='Modelo:'));

    else:
        print("\nNão foram encontrados dados para 'GASOLINA' no arquivo. O dashboard não pode ser gerado.")
else:
    print("\nO DataFrame não foi carregado. O dashboard não pode ser gerado.")